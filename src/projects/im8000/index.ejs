<!doctype html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport"
		content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<%- include("../../partials/_stylesheets.ejs") -%>
	<title>IM8000 | ImpendingMoon</title>
</head>

<body>
	<div id="page">
		<%- include("../../partials/_header.ejs", {currentPage: "projects"}) -%>
		<main>
			<section class="box">
				<h1>IM8000</h1>
				<p>
					The IM8000 is a homebrew instruction set architecture heavily inspired by the Zilog Z80.
					It is intended to fit between the complexity of the Intel 8086 and Motorola 68000, keeping the
					Z80's programming model.
				</p>
				<p>
					As a note, I am not a computer engineer. I made this for fun in my spare time, and it just so
					happens to be complete enough for me to share it.
				</p>

				<h2>Features</h2>
				<ul>
					<li>Wide 16 and 32-bit operand sizes</li>
					<li>Extremely orthogonal instruction set (which is sick until you need to pipeline it)</li>
					<li>Extended shadow register set, covering index registers</li>
					<li>Slightly improved indexed addressing (now including stack-relative!)</li>
					<li>Multiplication <em>and</em> division</li>
				</ul>

				<h2>History</h2>
				<p>
					I started on this project after digging into the Z8000, Z280, and eZ80's design.
					Zilog identified that the Z80 would make a poor base for a 16-bit processor, but the Z8000
					proved to be the wrong step forward.
				</p>
				<p>
					I began by experimenting with a 65816-esque design, keeping the same instruction encodings but
					extending them to 16-bit with extended operand/address flags. It was... just very okay. It was
					still an accumulator-based architecture with odd limitations.
				</p>
				<p>
					The IM8000 is a combination of a few more unnamed experiments, introducing more elements from
					the 8086, 68000, and some RISC processors. I experimented with different encodings, allowing all
					register pairs to use indexing mode, and adding instructions for C-style string operations.
					Most changes didn't stick. It all distilled down to the current architecture: A 16/32-bit
					processor with the same register set as the Z80, equivalents for most instructions, and a
					(in my opinion) very nice encoding scheme.
				</p>

				<h2>Documentation</h2>
				<p>
					The current reference document for the IM8000 can be found here:
					<a href="/files/im8000/im8000_technical_reference_manual_v05.pdf" target="_blank">
						IM8000_Technical_Reference<wbr>_Manual_v05.pdf
					</a>
				</p>
				<p class="no-margin-bottom">
					Previous versions of the reference document can be found here:
				</p>

				<ul>
					<li>
						<small>
							<a href="/files/im8000/im8000_technical_reference_manual_v03.pdf" target="_blank">
								IM8000_Technical_Reference<wbr>_Manual_v03.pdf
							</a>
						</small>
					</li>
				</ul>

				<br>

				<p>
					I am absolutely not a technical writer, and these are PDF exports of my Obsidian scratch files.
					I do plan on writing a more complete reference manual when the design is implemented somewhere.
				</p>
				<h2>Tools</h2>
				<p>
					I am working on an emulator/assembler, but I'm still up in the air about language and design.
					The C# emulator is the most complete, but still very incorrect in many places.
				</p>
				<p>
					There is no working assembler yet. I'm debating between rolling one from scratch or adding onto
					AS. Maybe both. I'm finding that I'm not very good at writing assemblers, so this may take a
					while.
				</p>
			</section>
		</main>
		<%- include("../../partials/_aside.ejs") -%>
		<%- include("../../partials/_footer.ejs") -%>
	</div>
</body>

</html>
